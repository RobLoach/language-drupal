'.text.drupal':
  'hook_field_storage_query':
    'prefix': 'hook_field_storage_query'
    'body': '/**\n * Implements hook_field_storage_query().\n */\nfunction $1_field_storage_query(\$query) {\n  /*\n   *  \$load_current = \$options[\'age\'] == FIELD_LOAD_CURRENT;\n   *\n   *  \$field = field_info_field_by_id(\$field_id);\n   *  \$field_name = \$field[\'field_name\'];\n   *  \$table = \$load_current ? _field_sql_storage_tablename(\$field) : _field_sql_storage_revision_tablename(\$field);\n   *  \$field_columns = array_keys(\$field[\'columns\']);\n   *\n   *  // Build the query.\n   *  \$query = db_select(\$table, \'t\');\n   *  \$query->join(\'field_config_entity_type\', \'e\', \'t.etid = e.etid\');\n   *\n   *  // Add conditions.\n   *  foreach (\$conditions as \$condition) {\n   *    // A condition is either a (column, value, operator) triple, or a\n   *    // (column, value) pair with implied operator.\n   *    @list(\$column, \$value, \$operator) = \$condition;\n   *    // Translate operator and value if needed.\n   *    switch (\$operator) {\n   *      case \'STARTS_WITH\':\n   *        \$operator = \'LIKE\';\n   *        \$value = db_like(\$value) . \'%\';\n   *        break;\n   *\n   *      case \'ENDS_WITH\':\n   *        \$operator = \'LIKE\';\n   *        \$value = \'%\' . db_like(\$value);\n   *        break;\n   *\n   *      case \'CONTAINS\':\n   *        \$operator = \'LIKE\';\n   *        \$value = \'%\' . db_like(\$value) . \'%\';\n   *        break;\n   *    }\n   *    // Translate field columns into prefixed db columns.\n   *    if (in_array(\$column, \$field_columns)) {\n   *      \$column = _field_sql_storage_columnname(\$field_name, \$column);\n   *    }\n   *    // Translate entity types into numeric ids. Expressing the condition on the\n   *    // local \'etid\' column rather than the JOINed \'type\' column avoids a\n   *    // filesort.\n   *    if (\$column == \'type\') {\n   *      \$column = \'t.etid\';\n   *      if (is_array(\$value)) {\n   *        foreach (array_keys(\$value) as \$key) {\n   *          \$value[\$key] = _field_sql_storage_etid(\$value[\$key]);\n   *        }\n   *      }\n   *      else {\n   *        \$value = _field_sql_storage_etid(\$value);\n   *      }\n   *    }\n   *    // Track condition on \'deleted\'.\n   *    if (\$column == \'deleted\') {\n   *      \$condition_deleted = TRUE;\n   *    }\n   *\n   *    \$query->condition(\$column, \$value, \$operator);\n   *  }\n   *\n   *  // Exclude deleted data unless we have a condition on it.\n   *  if (!isset(\$condition_deleted)) {\n   *    \$query->condition(\'deleted\', 0);\n   *  }\n   *\n   *  // For a count query, return the count now.\n   *  if (\$options[\'count\']) {\n   *    return \$query\n   *      ->fields(\'t\', array(\'etid\', \'entity_id\', \'revision_id\'))\n   *      ->distinct()\n   *      ->countQuery()\n   *      ->execute()\n   *      ->fetchField();\n   *  }\n   *\n   *  // For a data query, add fields.\n   *  \$query\n   *    ->fields(\'t\', array(\'bundle\', \'entity_id\', \'revision_id\'))\n   *    ->fields(\'e\', array(\'type\'))\n   *    // We need to ensure entities arrive in a consistent order for the\n   *    // range() operation to work.\n   *    ->orderBy(\'t.etid\')\n   *    ->orderBy(\'t.entity_id\');\n   *\n   *  // Initialize results array\n   *  \$return = array();\n   *\n   *  // Getting \$count entities possibly requires reading more than \$count rows\n   *  // since fields with multiple values span over several rows. We query for\n   *  // batches of \$count rows until we\'ve either read \$count entities or received\n   *  // less rows than asked for.\n   *  \$entity_count = 0;\n   *  do {\n   *    if (\$options[\'limit\'] != FIELD_QUERY_NO_LIMIT) {\n   *      \$query->range(\$options[\'cursor\'], \$options[\'limit\']);\n   *    }\n   *    \$results = \$query->execute();\n   *\n   *    \$row_count = 0;\n   *    foreach (\$results as \$row) {\n   *      \$row_count++;\n   *      \$options[\'cursor\']++;\n   *      // If querying all revisions and the entity type has revisions, we need\n   *      // to key the results by revision_ids.\n   *      \$entity_type = entity_get_info(\$row->type);\n   *      \$id = (\$load_current || empty(\$entity_type[\'entity keys\'][\'revision\'])) ? \$row->entity_id : \$row->revision_id;\n   *\n   *      if (!isset(\$return[\$row->type][\$id])) {\n   *        \$return[\$row->type][\$id] = entity_create_stub_entity(\$row->type, array(\$row->entity_id, \$row->revision_id, \$row->bundle));\n   *        \$entity_count++;\n   *      }\n   *    }\n   *  } while (\$options[\'limit\'] != FIELD_QUERY_NO_LIMIT && \$row_count == \$options[\'limit\'] && \$entity_count < \$options[\'limit\']);\n   *\n   *  // The query is complete when the last batch returns less rows than asked\n   *  // for.\n   *  if (\$row_count < \$options[\'limit\']) {\n   *    \$options[\'cursor\'] = FIELD_QUERY_COMPLETE;\n   *  }\n   *\n   *  return \$return;\n   */\n  ${1:/* Your code here */}\n}'